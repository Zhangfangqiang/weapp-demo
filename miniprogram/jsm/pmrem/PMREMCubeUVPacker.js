export default function(e){let{BackSide:b,CubeUVReflectionMapping:y,LinearFilter:w,LinearToneMapping:p,Mesh:C,NoBlending:r,OrthographicCamera:t,PlaneBufferGeometry:R,RGBEEncoding:T,RGBM16Encoding:U,Scene:n,ShaderMaterial:i,Vector2:j,Vector3:o,WebGLRenderTarget:I}=e;var a=function(){var v=new t;var s=new n;var M=a();var e=function(e){this.cubeLods=e;var a=e[0].width*4;var r=e[0].texture;var t={format:r.format,magFilter:r.magFilter,minFilter:r.minFilter,type:r.type,generateMipmaps:r.generateMipmaps,anisotropy:r.anisotropy,encoding:r.encoding===T?U:r.encoding};if(t.encoding===U){t.magFilter=w;t.minFilter=w}this.CubeUVRenderTarget=new I(a,a,t);this.CubeUVRenderTarget.texture.name="PMREMCubeUVPacker.cubeUv";this.CubeUVRenderTarget.texture.mapping=y;this.objects=[];var n=new R(1,1);var i=[];i.push(new j(0,0));i.push(new j(1,0));i.push(new j(2,0));i.push(new j(0,1));i.push(new j(1,1));i.push(new j(2,1));var o=a;a=e[0].width;var u=0;var v=4;this.numLods=Math.log(e[0].width)/Math.log(2)-2;for(var s=0;s<this.numLods;s++){var p=(o-o/v)*.5;if(a>16)v*=2;var c=a>16?6:1;var l=0;var m=0;var g=a;for(var d=0;d<c;d++){for(var f=0;f<6;f++){var h=M.clone();h.uniforms["envMap"].value=this.cubeLods[s].texture;h.envMap=this.cubeLods[s].texture;h.uniforms["faceIndex"].value=f;h.uniforms["mapSize"].value=g;var x=new C(n,h);x.position.x=i[f].x*g-p+l;x.position.y=i[f].y*g-p+u+m;x.material.side=b;x.scale.setScalar(g);this.objects.push(x)}m+=1.75*g;l+=1.25*g;g/=2}u+=2*a;if(a>16)a/=2}};e.prototype={constructor:e,update:function(e){var a=this.cubeLods[0].width*4;v.left=-a*.5;v.right=a*.5;v.top=-a*.5;v.bottom=a*.5;v.near=0;v.far=1;v.updateProjectionMatrix();for(var r=0;r<this.objects.length;r++){s.add(this.objects[r])}var t=e.gammaInput;var n=e.gammaOutput;var i=e.toneMapping;var o=e.toneMappingExposure;var u=e.getRenderTarget();e.gammaInput=false;e.gammaOutput=false;e.toneMapping=p;e.toneMappingExposure=1;e.setRenderTarget(this.CubeUVRenderTarget);e.render(s,v);e.setRenderTarget(u);e.toneMapping=i;e.toneMappingExposure=o;e.gammaInput=t;e.gammaOutput=n;for(var r=0;r<this.objects.length;r++){s.remove(this.objects[r])}},dispose:function(){for(var e=0,a=this.objects.length;e<a;e++){this.objects[e].material.dispose()}this.objects[0].geometry.dispose()}};function a(){var e=new i({uniforms:{faceIndex:{value:0},mapSize:{value:0},envMap:{value:null},testColor:{value:new o(1,1,1)}},vertexShader:"precision highp float;        varying vec2 vUv;        void main() {          vUv = uv;          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );        }",fragmentShader:"precision highp float;        varying vec2 vUv;        uniform samplerCube envMap;        uniform float mapSize;        uniform vec3 testColor;        uniform int faceIndex;                void main() {          vec3 sampleDirection;          vec2 uv = vUv;          uv = uv * 2.0 - 1.0;          uv.y *= -1.0;          if(faceIndex == 0) {            sampleDirection = normalize(vec3(1.0, uv.y, -uv.x));          } else if(faceIndex == 1) {            sampleDirection = normalize(vec3(uv.x, 1.0, uv.y));          } else if(faceIndex == 2) {            sampleDirection = normalize(vec3(uv.x, uv.y, 1.0));          } else if(faceIndex == 3) {            sampleDirection = normalize(vec3(-1.0, uv.y, uv.x));          } else if(faceIndex == 4) {            sampleDirection = normalize(vec3(uv.x, -1.0, -uv.y));          } else {            sampleDirection = normalize(vec3(-uv.x, uv.y, -1.0));          }          vec4 color = envMapTexelToLinear( textureCube( envMap, sampleDirection ) );          gl_FragColor = linearToOutputTexel( color );        }",blending:r});e.type="PMREMCubeUVPacker";return e}return e}();return{PMREMCubeUVPacker:a}}